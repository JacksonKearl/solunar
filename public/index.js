var Stations = [
    {
        "id": "8518091",
        "name": "RYE BEACH, AMUSEMENT PARK",
        "lat": 40.9617,
        "lng": -73.6717,
        "state": "NY",
        "timezone": "EST",
        "timezoneOffset": -5,
        "harcon": [
            {
                "name": "M2",
                "amplitude": 3.73,
                "phaseLag": 113.9
            },
            {
                "name": "S2",
                "amplitude": 0.62,
                "phaseLag": 140.8
            },
            {
                "name": "N2",
                "amplitude": 0.72,
                "phaseLag": 91.1
            },
            {
                "name": "K1",
                "amplitude": 0.32,
                "phaseLag": 192.6
            },
            {
                "name": "M4",
                "amplitude": 0.1,
                "phaseLag": 134.5
            },
            {
                "name": "O1",
                "amplitude": 0.22,
                "phaseLag": 217.6
            },
            {
                "name": "M6",
                "amplitude": 0.16,
                "phaseLag": 164.1
            },
            {
                "name": "MK",
                "amplitude": 0.04,
                "phaseLag": 205.6
            },
            {
                "name": "S4",
                "amplitude": 0.01,
                "phaseLag": 137.9
            },
            {
                "name": "MN",
                "amplitude": 0.05,
                "phaseLag": 115.3
            },
            {
                "name": "Nu2",
                "amplitude": 0.16,
                "phaseLag": 92
            },
            {
                "name": "Mu2",
                "amplitude": 0.02,
                "phaseLag": 263.7
            },
            {
                "name": "2N",
                "amplitude": 0.05,
                "phaseLag": 83.1
            },
            {
                "name": "OO",
                "amplitude": 0.02,
                "phaseLag": 231.6
            },
            {
                "name": "Lambda2",
                "amplitude": 0.08,
                "phaseLag": 144.1
            },
            {
                "name": "S1",
                "amplitude": 0.03,
                "phaseLag": 144.1
            },
            {
                "name": "M1",
                "amplitude": 0.01,
                "phaseLag": 221.7
            },
            {
                "name": "J1",
                "amplitude": 0.02,
                "phaseLag": 205.2
            },
            {
                "name": "Mm",
                "amplitude": 0.16,
                "phaseLag": 313
            },
            {
                "name": "Ssa",
                "amplitude": 0.12,
                "phaseLag": 64.6
            },
            {
                "name": "Sa",
                "amplitude": 0.23,
                "phaseLag": 112.3
            },
            {
                "name": "MSf",
                "amplitude": 0.07,
                "phaseLag": 278.5
            },
            {
                "name": "Mf",
                "amplitude": 0.04,
                "phaseLag": 257.4
            },
            {
                "name": "Rho1",
                "amplitude": 0.02,
                "phaseLag": 157.7
            },
            {
                "name": "Q1",
                "amplitude": 0.06,
                "phaseLag": 220.5
            },
            {
                "name": "T2",
                "amplitude": 0.06,
                "phaseLag": 101.2
            },
            {
                "name": "R2",
                "amplitude": 0.01,
                "phaseLag": 334.4
            },
            {
                "name": "2Q",
                "amplitude": 0.01,
                "phaseLag": 113.8
            },
            {
                "name": "P1",
                "amplitude": 0.08,
                "phaseLag": 205.4
            },
            {
                "name": "2SM",
                "amplitude": 0.02,
                "phaseLag": 95
            },
            {
                "name": "M3",
                "amplitude": 0.02,
                "phaseLag": 237
            },
            {
                "name": "L2",
                "amplitude": 0.23,
                "phaseLag": 162.1
            },
            {
                "name": "2MK",
                "amplitude": 0.03,
                "phaseLag": 215.7
            },
            {
                "name": "K2",
                "amplitude": 0.17,
                "phaseLag": 141
            },
            {
                "name": "M8",
                "amplitude": 0.01,
                "phaseLag": 216
            },
            {
                "name": "MS",
                "amplitude": 0.02,
                "phaseLag": 142.8
            }
        ]
    },
    {
        id: '9410580',
        name: 'NEWPORT BEACH, NEWPORT BAY ENTRANCE',
        lat: 33.6033,
        lng: -117.883,
        state: 'CA',
        timezone: 'PST',
        timezoneOffset: -8,
        harcon: [
            {
                name: 'M2',
                amplitude: 1.66,
                phaseLag: 144.4,
            },
            {
                name: 'S2',
                amplitude: 0.67,
                phaseLag: 140.2,
            },
            {
                name: 'N2',
                amplitude: 0.39,
                phaseLag: 124.1,
            },
            {
                name: 'K1',
                amplitude: 1.1,
                phaseLag: 208,
            },
            {
                name: 'M4',
                amplitude: 0.01,
                phaseLag: 282.4,
            },
            {
                name: 'O1',
                amplitude: 0.71,
                phaseLag: 192.7,
            },
            {
                name: 'Nu2',
                amplitude: 0.07,
                phaseLag: 126.2,
            },
            {
                name: 'Mu2',
                amplitude: 0.05,
                phaseLag: 84.2,
            },
            {
                name: '2N',
                amplitude: 0.05,
                phaseLag: 97.3,
            },
            {
                name: 'OO',
                amplitude: 0.04,
                phaseLag: 239.5,
            },
            {
                name: 'Lambda2',
                amplitude: 0.01,
                phaseLag: 142.4,
            },
            {
                name: 'S1',
                amplitude: 0.02,
                phaseLag: 312.8,
            },
            {
                name: 'M1',
                amplitude: 0.04,
                phaseLag: 218,
            },
            {
                name: 'J1',
                amplitude: 0.07,
                phaseLag: 218.4,
            },
            {
                name: 'Ssa',
                amplitude: 0.05,
                phaseLag: 280.2,
            },
            {
                name: 'Sa',
                amplitude: 0.21,
                phaseLag: 183.4,
            },
            {
                name: 'Rho1',
                amplitude: 0.03,
                phaseLag: 186.2,
            },
            {
                name: 'Q1',
                amplitude: 0.13,
                phaseLag: 184.4,
            },
            {
                name: 'T2',
                amplitude: 0.04,
                phaseLag: 128.8,
            },
            {
                name: 'R2',
                amplitude: 0.01,
                phaseLag: 140.1,
            },
            {
                name: '2Q',
                amplitude: 0.02,
                phaseLag: 177.5,
            },
            {
                name: 'P1',
                amplitude: 0.35,
                phaseLag: 203.3,
            },
            {
                name: 'M3',
                amplitude: 0.01,
                phaseLag: 354.2,
            },
            {
                name: 'L2',
                amplitude: 0.05,
                phaseLag: 148,
            },
            {
                name: 'K2',
                amplitude: 0.2,
                phaseLag: 133.1,
            },
        ],
    },
];

const dot = (a, b) => {
    const l = Math.min(a.length, b.length);
    let result = 0;
    for (let i = 0; i < l; i++) {
        result += (a[i] ?? 0) * (b[i] ?? 0);
    }
    return result;
};
const scale = (value, inMin, inMax, outMin, outMax) => ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
/** rescale amt from 0-1 to min-max */
const sploot = (amt, min, max) => scale(amt, 0, 1, min, max);
const bound2 = (val, min, max) => Math.max(min, Math.min(val, max));
performance.now();
class Observable {
    view;
    value;
    watchers = new Set();
    constructor() {
        this.view = (w) => {
            this.watchers.add(w);
            if (this.value) {
                w(this.value);
            }
            return { dispose: () => this.watchers.delete(w) };
        };
    }
    set(v) {
        if (v !== this.value) {
            this.value = v;
            this.watchers.forEach((w) => w(v));
        }
    }
}
const MappedView = (view, mapper) => (watcher) => {
    const disposable = view((v) => watcher(mapper(v)));
    return { dispose: () => disposable.dispose() };
};
class DisposableStore {
    store = new Set();
    isDisposed = false;
    clear() {
        this.store.forEach((d) => d.dispose());
        this.store.clear();
    }
    add(...ds) {
        if (this.isDisposed) {
            console.trace('Alert! Attempting to add to a disposed store! These objects will be immediately disposed.', ds);
            ds.forEach((d) => d.dispose());
        }
        else {
            ds.forEach((d) => this.store.add(d));
        }
        return ds;
    }
    dispose() {
        this.clear();
        this.isDisposed = true;
    }
}

const addElementListener = (element, type, listener, options) => {
    element.addEventListener(type, listener, options);
    return { dispose: () => element.removeEventListener(type, listener) };
};
const findDPR = () => window.devicePixelRatio || 1;

const radToDeg = (rad) => (rad * 180) / Math.PI;
const degToRad = (deg) => (deg * Math.PI) / 180;
const sin = (deg) => Math.sin(degToRad(deg));
const cos = (deg) => Math.cos(degToRad(deg));
const acos = (val) => radToDeg(Math.acos(val));
const tan = (deg) => Math.tan(degToRad(deg));
const atan = (val) => radToDeg(Math.atan(val));
const cot = (deg) => 1 / tan(deg);
const wrap = (deg, limit = 360) => ((deg % limit) + limit) % limit;

const drawZoneForElement = (el) => {
    const dpr = findDPR();
    return {
        top: el.offsetTop * dpr,
        left: el.offsetLeft * dpr,
        height: el.offsetHeight * dpr,
        width: el.offsetWidth * dpr,
    };
};
const setupCanvas = (canvas) => {
    const dpr = findDPR();
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    const dim = {
        top: 0,
        left: 0,
        bottom: canvas.height,
        right: canvas.width,
        centerY: canvas.height / 2,
        centerX: canvas.width / 2,
        minDim: Math.min(canvas.height, canvas.width),
        width: canvas.width,
        height: canvas.height,
    };
    return { ctx, dim };
};
class CanvasElement {
    context;
    store = new DisposableStore();
    dimensions;
    disposed = false;
    scaleFactor;
    active = false;
    onClick(l) { }
    onDrag(l) { }
    constructor(context, drawZone) {
        this.context = context;
        this.dimensions = {
            top: drawZone.top,
            bottom: drawZone.top + drawZone.height,
            left: drawZone.left,
            right: drawZone.left + drawZone.width,
            centerY: drawZone.top + drawZone.height / 2,
            centerX: drawZone.left + drawZone.width / 2,
            width: drawZone.width,
            height: drawZone.height,
            minDim: Math.min(drawZone.height, drawZone.width),
        };
        const touchTracker = new Map();
        this.scaleFactor = this.dimensions.minDim / 2;
        this.store.add({ dispose: () => (this.disposed = true) });
        this.store.add(addElementListener(this.context.canvas, 'touchstart', (e) => {
            const l = this.locationOfEvent(e);
            if (l && this.locationInDrawZone(l)) {
                touchTracker.set(e.touches[0].identifier, l);
                this.active = true;
            }
        }), addElementListener(this.context.canvas, 'mousedown', (e) => {
            const l = this.locationOfEvent(e);
            if (this.locationInDrawZone(l)) {
                this.active = true;
            }
        }), addElementListener(this.context.canvas, 'touchend', (e) => {
            const l = this.locationOfEvent(e);
            if (l && this.locationInDrawZone(l) && this.active) {
                this.onClick(l);
            }
            this.active = false;
            touchTracker.delete(e.touches[0].identifier);
        }), addElementListener(this.context.canvas, 'mouseup', (e) => {
            const l = this.locationOfEvent(e);
            if (l && this.locationInDrawZone(l) && this.active) {
                this.onClick(l);
            }
            this.active = false;
        }), addElementListener(this.context.canvas, 'touchcancel', (e) => {
            this.active = false;
            touchTracker.delete(e.touches[0].identifier);
        }), addElementListener(this.context.canvas, 'mouseleave', (e) => {
            this.active = false;
        }), addElementListener(this.context.canvas, 'mousemove', (e) => {
            if (this.active && e.buttons) {
                const dpr = findDPR();
                this.onDrag({
                    dx: e.movementX * dpr,
                    dy: e.movementY * dpr,
                    x: e.pageX * dpr,
                    y: e.pageY * dpr,
                });
            }
        }), addElementListener(this.context.canvas, 'touchmove', (e) => {
            if (this.active && e.touches.length === 1) {
                e.preventDefault();
                const touch = e.touches[0];
                const priorTouch = touchTracker.get(touch.identifier);
                const movementX = priorTouch ? touch.pageX - priorTouch.x : 0;
                const movementY = priorTouch ? touch.pageY - priorTouch.y : 0;
                const dpr = findDPR();
                const location = { x: touch.pageX * dpr, y: touch.pageY * dpr };
                this.onDrag({
                    dx: movementX * dpr,
                    dy: movementY * dpr,
                    ...location,
                });
                touchTracker.set(touch.identifier, location);
            }
        }));
    }
    locationOfEvent(m) {
        let e;
        if (m instanceof TouchEvent) {
            if (m.touches.length !== 1)
                return undefined;
            e = m.touches[0];
        }
        else {
            e = m;
        }
        const dpr = findDPR();
        return { x: e.pageX * dpr, y: e.pageY * dpr };
    }
    locationInRadius(l, r) {
        if (!l)
            return false;
        const { x, y } = l;
        return (Math.sqrt((x - this.dimensions.centerX) ** 2 + (y - this.dimensions.centerY) ** 2) <
            this.scaleFactor * r);
    }
    locationInDrawZone(l) {
        if (!l)
            return false;
        return (bound2(l.x, this.dimensions.left, this.dimensions.right) === l.x &&
            bound2(l.y, this.dimensions.top, this.dimensions.bottom) === l.y);
    }
    setLineWidth(l) {
        this.context.lineWidth = this.scaleFactor * l;
    }
    traceCircle(r, x = 0, y = 0) {
        const { canvasX, canvasY } = this.xyToCanvasCoords(x, y);
        this.context.arc(canvasX, canvasY, this.scaleFactor * r, 0, 2 * Math.PI);
    }
    traceLine(x, y) {
        const { canvasX, canvasY } = this.xyToCanvasCoords(x, y);
        this.context.lineTo(canvasX, canvasY);
    }
    xyToCanvasCoords(x, y) {
        return {
            canvasX: this.dimensions.centerX + this.scaleFactor * x,
            canvasY: this.dimensions.centerY + this.scaleFactor * y,
        };
    }
    getRect(r, deg) {
        return {
            x: r * cos(deg),
            y: r * -sin(deg),
        };
    }
    withRotation(deg, centerX, centerY, cb) {
        const { canvasX, canvasY } = this.xyToCanvasCoords(centerX, centerY);
        this.context.translate(canvasX, canvasY);
        this.context.rotate(-degToRad(deg));
        this.context.translate(-canvasX, -canvasY);
        cb();
        this.context.translate(canvasX, canvasY);
        this.context.rotate(degToRad(deg));
        this.context.translate(-canvasX, -canvasY);
    }
    traceRay(r, deg, startX = 0, startY = 0, offset = 0) {
        if (offset) {
            this.moveTo(startX + offset * cos(deg), startY - offset * sin(deg));
        }
        this.traceLine(startX + r * cos(deg), startY - r * sin(deg));
    }
    moveTo(x, y) {
        this.context.moveTo(this.dimensions.centerX + this.scaleFactor * x, this.dimensions.centerY + this.scaleFactor * y);
    }
    fillText(x, y, text, justify = 'center') {
        const textProps = this.context.measureText(text);
        const xJustifyAdjust = {
            center: textProps.width / 2,
            left: 0,
            right: textProps.width,
        }[justify];
        const yJustifyAdjust = textProps.actualBoundingBoxAscent / 2;
        this.context.fillText(text, this.dimensions.centerX + this.scaleFactor * x - xJustifyAdjust, this.dimensions.centerY + this.scaleFactor * y + yJustifyAdjust);
    }
    dispose() {
        this.store.clear();
    }
}

class Slider extends CanvasElement {
    options;
    vertical;
    value = new Observable();
    valueView = this.value.view;
    constructor(context, drawZone, options) {
        super(context, drawZone);
        this.options = options;
        this.vertical = this.dimensions.height > this.dimensions.width;
        this.value.set(options.value);
        this.scaleFactor = (this.vertical ? drawZone.height : drawZone.width) / 2;
    }
    onDrag(l) {
        this.handleTouch(l);
    }
    onClick(l) {
        this.handleTouch(l);
    }
    handleTouch(l) {
        const scaleVal = this.vertical
            ? scale(l.y, this.dimensions.bottom - this.scaleFactor * 0.1, this.dimensions.top + this.scaleFactor * 0.1, this.options.min, this.options.max)
            : scale(l.x, this.dimensions.left + this.scaleFactor * 0.1, this.dimensions.right - this.scaleFactor * 0.1, this.options.min, this.options.max);
        const boundVal = bound2(scaleVal, this.options.min, this.options.max);
        this.options.value = boundVal;
        this.value.set(boundVal);
        this.render();
    }
    render() {
        this.context.fillStyle = '#333';
        this.context.fillRect(this.dimensions.left, this.dimensions.top, this.dimensions.width, this.dimensions.height);
        this.context.save();
        this.context.beginPath();
        const [dX, dY] = this.vertical ? [0, 1] : [1, 0];
        this.moveTo(-dX, -dY);
        this.traceLine(dX, dY);
        this.context.lineWidth = 10;
        this.context.strokeStyle = '#111';
        this.context.stroke();
        this.context.beginPath();
        const y = this.vertical
            ? scale(this.options.value, this.options.min, this.options.max, 0.9, -0.9)
            : 0;
        const x = this.vertical
            ? 0
            : scale(this.options.value, this.options.min, this.options.max, -0.9, 0.9);
        this.traceCircle(0.1, x, y);
        this.context.fillStyle = '#444';
        this.context.fill();
        this.context.beginPath();
        this.traceCircle(0.05, x, y);
        this.context.fillStyle = '#f0f';
        this.context.fill();
        this.context.restore();
    }
}

class Toggle extends CanvasElement {
    options;
    value = new Observable();
    valueView = this.value.view;
    constructor(context, drawZone, options) {
        super(context, drawZone);
        this.options = options;
        this.value.set(options.value);
        this.scaleFactor = this.dimensions.minDim * 0.15;
    }
    onClick(l) {
        if (this.locationInRadius(l, 2)) {
            this.options.value = !this.options.value;
            this.value.set(this.options.value);
            this.render();
        }
    }
    render() {
        this.context.fillStyle = '#333';
        this.context.fillRect(this.dimensions.left, this.dimensions.top, this.dimensions.width, this.dimensions.height);
        this.context.save();
        this.context.beginPath();
        this.traceCircle(0.7);
        this.context.lineWidth = this.scaleFactor / 10;
        this.context.fillStyle = '#000';
        this.context.fill();
        this.context.strokeStyle = '#fff';
        this.context.stroke();
        this.context.fillStyle = '#fff';
        const mainLabelSize = this.scaleFactor * 0.9 + 'px';
        this.context.font = mainLabelSize + ' system-ui';
        this.fillText(0, -2.7, this.options.label.toLocaleUpperCase());
        const optionLabelSize = this.scaleFactor * 0.5 + 'px';
        this.context.font = optionLabelSize + ' system-ui';
        this.fillText(0, -1.5, this.options.onLabel.toLocaleUpperCase());
        this.fillText(0, +1.5, this.options.offLabel.toLocaleUpperCase());
        this.context.beginPath();
        this.traceCircle(0.4);
        this.context.fillStyle = '#555';
        this.context.fill();
        const flipper = this.options.value ? -1 : 1;
        this.context.beginPath();
        this.context.fillStyle = '#888';
        this.moveTo(0, 0);
        this.traceLine(-0.1, 0.05 * flipper);
        this.traceLine(+0.1, 0.05 * flipper);
        this.traceLine(+0.4, 1.0 * flipper);
        this.traceLine(+0.0, 1.3 * flipper);
        this.traceLine(-0.4, 1.0 * flipper);
        this.traceLine(-0.1, 0.05 * flipper);
        this.context.fill();
        this.context.beginPath();
        this.context.fillStyle = '#999';
        this.traceLine(+0.4, 1.0 * flipper);
        this.traceLine(0, 1.3 * flipper);
        this.traceLine(-0.4, 1.0 * flipper);
        this.context.closePath();
        this.context.fill();
        this.context.restore();
    }
}

// 1/Qa = [ 1/4 + (3/2 cos I / cos^2 1/2 I) * cos 2P + 9/4 cos^2 I / cos^4 1/2 I ]^(1/2)
// Schureman, page 47
const QaInv = (l) => Math.sqrt(1 / 4 +
    (3 / 2) * (cos(l.I) / cos(l.I / 2) ** 2) * cos(2 * l.P) +
    (9 / 4) * (cos(l.I) ** 2 / cos(l.I / 2) ** 4));
// 1/Ra = (1 - 12 tan^2 1/2 I cos 2P + 36tan^4 I/2)^(1/2)
// Schureman, page 50
const RaInv = (l) => Math.sqrt(1 - 12 * tan(l.I / 2) ** 2 * cos(2 * l.P) + 36 * tan(l.I / 2) ** 4);
const FactorFs = {
    73: ({ I }) => (2 / 3 - sin(I) ** 2) / 0.5021,
    74: ({ I }) => sin(I) ** 2 / 0.1578,
    75: ({ I }) => (sin(I) * cos(I / 2) ** 2) / 0.38,
    76: ({ I }) => sin(2 * I) / 0.7214,
    77: ({ I }) => (sin(I) * sin(I / 2) ** 2) / 0.0164,
    78: ({ I }) => cos(I / 2) ** 4 / 0.9154,
    149: ({ I }) => cos(I / 2) ** 6 / 0.8758,
    206: (l) => FactorFs[75](l) * QaInv(l),
    215: (l) => FactorFs[78](l) * RaInv(l),
    227: ({ I, Nu }) => Math.sqrt(0.8965 * sin(2 * I) ** 2 + 0.6001 * sin(2 * I) * cos(Nu) + 0.1006),
    235: ({ I, Nu }) => Math.sqrt(19.0444 * sin(I) ** 4 + 2.7702 * sin(I) ** 2 * cos(2 * Nu) + 0.0981),
};

const unity = () => 1;
// Schureman, page 180
const Constituents = {
    'J1': {
        V: [1, 1, 1, -1, 0, -90],
        u: [0, -1],
        f: FactorFs[76],
    },
    'K1': {
        V: [1, 0, 1, 0, 0, -90],
        u: [0, 0, -1],
        f: FactorFs[227],
    },
    'K2': {
        V: [2, 0, 2],
        u: [0, 0, 0, -2],
        f: FactorFs[235],
    },
    'L2': {
        V: [2, -1, 2, -1, 0, 180],
        u: [2, -2, 0, 0, -1],
        f: FactorFs[215],
    },
    'M1': {
        V: [1, -1, 1, 0, 0, -90],
        u: [1, -1, 0, 0, 0, 1],
        f: FactorFs[206],
    },
    'M2': {
        V: [2, -2, 2],
        u: [2, -2],
        f: FactorFs[78],
    },
    'M3': {
        V: [3, -3, 3],
        u: [3, -3],
        f: FactorFs[149],
    },
    'M4': {
        V: [4, -4, 4],
        u: [4, -4],
        f: (l) => Constituents.M2.f(l) ** 2,
    },
    'M6': {
        V: [6, -6, 6],
        u: [6, -6],
        f: (l) => Constituents.M2.f(l) ** 3,
    },
    'M8': {
        V: [8, -8, 8],
        u: [8, -8],
        f: (l) => Constituents.M2.f(l) ** 4,
    },
    'N2': {
        V: [2, -3, 2, 1],
        u: [2, -2],
        f: FactorFs[78],
    },
    '2N': {
        V: [2, -4, 2, 2],
        u: [2, -2],
        f: FactorFs[78],
    },
    'O1': {
        V: [1, -2, 1, 0, 0, 90],
        u: [2, -1],
        f: FactorFs[75],
    },
    'OO': {
        V: [1, 2, 1, 0, 0, -90],
        u: [-2, -1],
        f: FactorFs[77],
    },
    'P1': { V: [1, 0, -1, 0, 0, 90], u: [], f: unity },
    'Q1': {
        V: [1, -3, 1, 1, 0, 90],
        u: [2, -1],
        f: FactorFs[75],
    },
    '2Q': {
        V: [1, -4, 1, 2, 0, 90],
        u: [2, -1],
        f: FactorFs[75],
    },
    'R2': { V: [2, 0, 1, 0, -1, 180], u: [], f: unity },
    'S1': { V: [1], u: [], f: unity },
    'S2': { V: [2], u: [], f: unity },
    'S4': { V: [4], u: [], f: unity },
    'S6': { V: [6], u: [], f: unity },
    'T2': { V: [2, 0, -1, 0, 1], u: [], f: unity },
    'Lambda2': {
        V: [2, -1, 0, 1, 0, 180],
        u: [2, -2],
        f: FactorFs[78],
    },
    'Mu2': {
        V: [2, -4, 4],
        u: [2, -2],
        f: FactorFs[78],
    },
    'Nu2': {
        V: [2, -3, 4, -1],
        u: [2, -2],
        f: FactorFs[78],
    },
    'Rho1': {
        V: [1, -3, 3, -1, 0, 90],
        u: [2, -1],
        f: FactorFs[75],
    },
    'MK': {
        V: [3, -2, 3, 0, 0, -90],
        u: [2, -2, -1],
        f: (l) => Constituents.M2.f(l) * Constituents.K1.f(l),
    },
    '2MK': {
        V: [3, -4, 3, 0, 0, 90],
        u: [4, -4, 1],
        f: (l) => Constituents.M2.f(l) ** 2 * Constituents.K1.f(l),
    },
    'MN': {
        V: [4, -5, 4, 1],
        u: [4, -4],
        f: (l) => Constituents.M2.f(l) ** 2,
    },
    'MS': {
        V: [4, -2, 2],
        u: [2, -2],
        f: (l) => Constituents.M2.f(l) ** 2,
    },
    '2SM': {
        V: [2, 2, -2],
        u: [-2, 2],
        f: (l) => Constituents.M2.f(l),
    },
    'Mf': { V: [0, 2], u: [-2], f: FactorFs[74] },
    'MSf': { V: [0, 2, -2], u: [], f: FactorFs[73] },
    'Mm': { V: [0, 1, 0, -1], u: [], f: FactorFs[73] },
    'Sa': { V: [0, 0, 1], u: [], f: unity },
    'Ssa': { V: [0, 0, 2], u: [], f: unity },
};

const OrbitStateToArray = (o) => [o.T, o.s, o.h, o.p, o.p1, 1];
// Schureman, page 179
const OrbitVelocities = {
    T: 15,
    s: 0.54901653,
    h: 0.041068639,
    p: 0.00464183,
    p1: 0.00000196,
    N: -0.00220641,
};
const EpochTime = new Date('1900');
const OrbitAtTime = (time) => {
    const deltaHours = (+time - +EpochTime) / 1000 / 60 / 60;
    return {
        T: +OrbitVelocities.T * deltaHours + 180,
        s: +OrbitVelocities.s * deltaHours + 277.026,
        h: +OrbitVelocities.h * deltaHours + 280.19,
        p: +OrbitVelocities.p * deltaHours + 334.384,
        p1: +OrbitVelocities.p1 * deltaHours + 281.221,
        N: +OrbitVelocities.N * deltaHours + 259.156,
    };
};
const LunarNodeStateToArray = (s) => [
    s.Xi,
    s.Nu,
    s.NuPrime,
    s.NuDoublePrime,
    s.R,
    s.Q,
];
const LunarNodeStateForOrbit = (orbit) => {
    const { N, p } = orbit;
    // tan 1/2 (N - Xi + Nu) = 1.01883 tan 1/2 N
    // tan 1/2 (N - Xi - Nu) = 0.64412 tan 1/2 N
    // Schureman, page 172
    const i = atan(1.01883 * tan(N / 2));
    const j = atan(0.64412 * tan(N / 2));
    const Nu = i - j;
    const Xi = N - i - j;
    // cos(I) = 0.91370 - 0.03569 * cos(N)
    // Schureman, page 172
    const I = acos(0.9137 - 0.03569 * cos(N));
    // Nu' = atan[ ( sin 2I sin Nu ) / ( sin 2I cos Nu + 0.3347 ) ]
    // Schureman, page 51
    const NuPrime = atan((sin(2 * I) * sin(Nu)) / (sin(2 * I) * cos(Nu) + 0.3347));
    // 2Nu'' = atan[ ( sin^2 I * sin 2Nu ) / ( sin^2 I cos 2Nu + 0.0727 ) ]
    // Schureman, page 52
    const NuDoublePrime = atan((sin(I) ** 2 * sin(2 * Nu)) / (sin(I) ** 2 * cos(2 * Nu) + 0.0727)) / 2;
    // p = P + Xi
    // Schureman, page 47
    const P = wrap(p - Xi);
    // R = atan[ sin 2P / ( 1/6 cot^2 1/2 I - cos 2P ) ]
    // Schureman, page 50
    const R = atan(sin(2 * P) / (cot(I / 2) ** 2 / 6 - cos(2 * P)));
    // Q = atan [ (5 cos I - 1) / (7 cos I + 1) * tan P ]
    // Schureman, page 48
    const Q = atan(((5 * cos(I) - 1) / (7 * cos(I) + 1)) * tan(P)) +
        // Adjustment for quadrant selection
        (P > 90 ? 180 : 0) +
        (P > 270 ? 180 : 0);
    return { Xi, Nu, NuPrime, NuDoublePrime, R, Q, I, P };
};
const UniversalStateAtTime = (time) => {
    const orbit = OrbitAtTime(time);
    const lunarNode = LunarNodeStateForOrbit(orbit);
    const orbitVector = OrbitStateToArray(orbit);
    const lunarVector = LunarNodeStateToArray(lunarNode);
    return { orbitVector, lunarVector, lunarNode };
};
const StationLevelAtTime = (station, time, includeConstituent = () => true) => {
    const vT = UniversalStateAtTime(time);
    const vTNext = UniversalStateAtTime(+time + 1000);
    const constituents = {};
    let totalOffset = 0;
    for (const harmonic of station.harcon) {
        const cData = Constituents[harmonic.name];
        const Vu = dot(cData.V, vT.orbitVector) + dot(cData.u, vT.lunarVector);
        const VuNext = dot(cData.V, vTNext.orbitVector) + dot(cData.u, vTNext.lunarVector);
        const degreesPerSecond = VuNext - Vu;
        const f = cData.f(vT.lunarNode);
        const phaseLag = harmonic.phaseLag;
        const amplitude = f * harmonic.amplitude;
        const argument = wrap(Vu - phaseLag);
        const offset = f * amplitude * cos(argument);
        const constituentContribution = {
            amplitude,
            argument,
            degreesPerSecond,
        };
        if (!includeConstituent(constituentContribution)) {
            continue;
        }
        constituents[harmonic.name] = constituentContribution;
        totalOffset += offset;
    }
    return { total: totalOffset, constituents, time };
};
// An Epoch for New Moons. Astronomical Algorithms, Jean Meeus
const FirstLunation = new Date('2000-01-06T18:14');
// Synodical Month, Schureman, page 179
const LunarSynodicalSpeed = OrbitVelocities.s - OrbitVelocities.h;
const MoonSynodicalAngleAtTime = (time) => {
    const deltaHours = (time - +FirstLunation) / (1000 * 60 * 60);
    const deltaDegrees = deltaHours * LunarSynodicalSpeed;
    return wrap(deltaDegrees);
};
// Tropical Month, Schureman, page 179
const LunarTropicalSpeed = OrbitVelocities.s;
const MoonTropicalAngleAtTime = (time) => {
    const phaseOffset = SolarAngleAtTime(+FirstLunation);
    const deltaHours = (time - +FirstLunation) / (1000 * 60 * 60);
    const deltaDegrees = deltaHours * LunarTropicalSpeed + phaseOffset;
    return wrap(deltaDegrees);
};
const SolarAngleAtTime = (time) => {
    const yearStart = new Date(time);
    yearStart.setUTCMonth(0, 1);
    yearStart.setUTCHours(0, 0, 0, 0);
    const yearEnd = new Date(yearStart);
    yearEnd.setUTCFullYear(yearStart.getUTCFullYear() + 1);
    return scale(time, +yearStart, +yearEnd, 0, 360);
};

class TideOScope extends CanvasElement {
    station;
    options;
    activeRadius;
    data;
    lastFetchWallTime;
    centralDataObservable = new Observable();
    centralDataView = this.centralDataObservable.view;
    constructor(context, drawZone, station, options) {
        super(context, drawZone);
        this.station = station;
        this.options = options;
        this.activeRadius = this.dimensions.minDim * (49 / 100);
        this.scaleFactor = this.activeRadius;
        this.data = this.fetchAllData();
        this.resetAutoAdvanceTimer();
        this.store.add({ dispose: () => this.autoAdvanceDisposables.clear() });
    }
    attachObservable(inputName, view) {
        const toRunOnChange = {
            center: () => {
                this.fetchAllData();
            },
            timeRange: () => {
                this.resetAutoAdvanceTimer();
                this.fetchAllData();
            },
            timeRate: () => {
                this.resetAutoAdvanceTimer();
                this.moveCenterWithTime();
            },
            periodLoPass: () => {
                this.fetchAllData();
            },
            periodHiPass: () => {
                this.fetchAllData();
            },
        };
        this.store.add(view((v) => {
            if (this.options[inputName] !== v) {
                this.options[inputName] = v;
                requestAnimationFrame(() => this.render());
                toRunOnChange[inputName]?.();
            }
        }));
    }
    // reads: renderScale, timeRange, timeRate, data
    // writes: center, data
    onDrag(l) {
        if (this.locationInRadius(l, 1)) {
            this.panLevels((l.dx * -1) / this.options.renderScale);
        }
    }
    // reads: timeRange, timeRate, data, periodHiPass, periodLoPass
    // writes: center, data
    panAccumulator = 0;
    panLevels(numIndices) {
        this.panAccumulator += numIndices;
        const amtToMove = Math.round(this.panAccumulator);
        const timePerPixel = this.options.timeRange / this.activeRadius;
        if (Math.abs(amtToMove) > 1) {
            if (amtToMove > 0) {
                let cursor = +this.data[this.data.length - 1].time;
                for (let i = 0; i < amtToMove; i++) {
                    cursor += timePerPixel * this.options.renderScale;
                    this.data.shift();
                    this.data.push(this.stationLevelAtTime(cursor));
                    this.panAccumulator--;
                }
            }
            else {
                let cursor = +this.data[0].time;
                for (let i = 0; i < -amtToMove; i++) {
                    cursor -= timePerPixel * this.options.renderScale;
                    this.data.pop();
                    this.data.unshift(this.stationLevelAtTime(cursor));
                    this.panAccumulator++;
                }
            }
        }
        this.options.center += amtToMove * timePerPixel;
        this.fetchCentralData();
        this.render();
    }
    // reads timeRate
    // writes: center, data
    moveCenterWithTime() {
        const t = Date.now();
        if (this.disposed)
            return;
        if (this.active) {
            this.lastFetchWallTime = undefined;
        }
        else {
            const delta = this.lastFetchWallTime === undefined || t === undefined
                ? 0
                : t - this.lastFetchWallTime;
            this.options.center += delta * this.options.timeRate;
            this.fetchAllData();
        }
    }
    // reads: timeRange, timeRate
    autoAdvanceDisposables = new DisposableStore();
    resetAutoAdvanceTimer() {
        this.autoAdvanceDisposables.clear();
        const timeout = bound2((60 / this.options.timeRate) * 1000, 0, 5000);
        const doFrameUpdate = () => {
            if (!this.active) {
                this.moveCenterWithTime();
                this.render();
            }
            this.resetAutoAdvanceTimer();
        };
        if (timeout < 10) {
            const handle = window.requestAnimationFrame(doFrameUpdate);
            this.autoAdvanceDisposables.add({
                dispose: () => window.cancelAnimationFrame(handle),
            });
        }
        else {
            const handle = window.setTimeout(doFrameUpdate, timeout);
            this.autoAdvanceDisposables.add({
                dispose: () => window.clearTimeout(handle),
            });
        }
    }
    // reads: center, timeRange, periodHiPass, periodLoPass
    // writes: data
    fetchAllData() {
        this.lastFetchWallTime = Date.now();
        const start = this.options.center - this.options.timeRange;
        const end = this.options.center + this.options.timeRange;
        const levels = [];
        for (let i = 0; i <= this.activeRadius * 2 + this.options.renderScale; i += this.options.renderScale) {
            const percWidth = i / (this.activeRadius * 2);
            const cursorTime = sploot(percWidth, start, end);
            levels.push(this.stationLevelAtTime(cursorTime));
        }
        this.fetchCentralData();
        return (this.data = levels);
    }
    // reads: center, data, renderHarmonics, renderMoon, renderSun, render12Hour, render24Hour, timeRange, timeRate, periodHiPass, periodLoPass
    render() {
        // logTime('tideOScope Render')
        this.context.save();
        this.renderClippingPath();
        this.renderBackground();
        this.renderTidePlot();
        if (this.options.renderHarmonics) {
            this.renderHarmonics();
        }
        if (this.options.renderMoon) {
            this.renderMoon();
        }
        if (this.options.renderSun) {
            this.renderSun();
        }
        this.renderCrosshairs();
        this.context.restore();
        // this.resetAutoAdvanceTimer()
    }
    // reads: data, yRange
    renderTidePlot() {
        this.context.fillStyle = '#5a0073';
        this.context.beginPath();
        this.context.moveTo(this.dimensions.left, this.dimensions.bottom);
        for (let i = 0; i < this.data.length; i++) {
            const start = this.dimensions.centerX - this.activeRadius;
            this.context.lineTo(start + i * this.options.renderScale, scale(this.data[i].total, -this.options.yRange, this.options.yRange, this.dimensions.centerY + this.activeRadius, this.dimensions.centerY - this.activeRadius));
        }
        this.context.lineTo(this.dimensions.right, this.dimensions.bottom);
        this.context.closePath();
        this.context.fill();
    }
    // reads: center, periodHiPass, periodLoPass
    fetchCentralData() {
        this.centralDataObservable.set(this.stationLevelAtTime(this.options.center));
    }
    // reads: center, periodHiPass, periodLoPass
    get centralData() {
        return this.stationLevelAtTime(this.options.center);
    }
    // reads: center
    renderMoon() {
        const moonSynodicalAngle = MoonSynodicalAngleAtTime(this.centralData.time);
        const moonTropicalAngle = MoonTropicalAngleAtTime(this.centralData.time);
        const { x, y } = this.getCoordForData(moonTropicalAngle, {
            revsPerHour: LunarTropicalSpeed / 360,
        });
        this.context.fillStyle = '#eeeeee';
        const percentCycle = wrap(moonSynodicalAngle) / 360;
        const outsidePath = [];
        const insidePath = [];
        const radius = this.activeRadius / 15;
        for (let y = -radius; y <= radius; y++) {
            if (percentCycle < 0.5) {
                const xCircle = Math.sqrt(radius ** 2 - y ** 2);
                outsidePath.push([y, xCircle]);
                insidePath.push([y, scale(percentCycle, 0, 0.5, 1, -1) * xCircle]);
            }
            else {
                const xLead = -Math.sqrt(radius ** 2 - y ** 2);
                outsidePath.push([y, xLead]);
                insidePath.push([y, scale(percentCycle, 0.5, 1, -1, 1) * xLead]);
            }
        }
        this.context.beginPath();
        for (const [dy, dx] of [...outsidePath, ...insidePath.reverse()]) {
            this.context.lineTo(x + dx, y + dy);
        }
        this.context.fill();
    }
    // reads: center
    renderSun() {
        const sunPhaseAngle = SolarAngleAtTime(this.centralData.time);
        const { x, y } = this.getCoordForData(sunPhaseAngle, {
            daysPerRev: 365.25,
        });
        this.context.fillStyle = '#F1CE01';
        this.context.beginPath();
        const radius = this.activeRadius / 15;
        this.context.arc(x, y, radius, 0, 2 * Math.PI);
        this.context.fill();
    }
    // reads: center
    renderHarmonics() {
        const constituentData = Object.entries(this.centralData.constituents).sort(([, a], [, b]) => b.amplitude - a.amplitude);
        for (const [name, data] of constituentData) {
            if (data && data.amplitude > 0.0) {
                const { x, y, r } = this.getCoordForData(data.argument, {
                    revsPerHour: (data.degreesPerSecond * 60 * 60) / 360,
                });
                const radius = (data.amplitude * r ** 2) ** (1 / 3);
                const eq = Constituents[name];
                const [T, s, h] = [...eq.V, 0, 0, 0].map((x) => Math.abs(x));
                const max = T + s + h + 0.5;
                const greenBlue = T;
                const blueRed = s;
                const redGreen = h;
                const rgb = [
                    scale(redGreen + blueRed, 0, max, 0, 255),
                    scale(redGreen + greenBlue, 0, max, 0, 255),
                    scale(blueRed + greenBlue, 0, max, 0, 255),
                ];
                const alpha = 230;
                const toTwoDigitHexString = (n) => Math.round(n).toString(16).padStart(2, '0');
                const color = `#` + [...rgb, alpha].map(toTwoDigitHexString).join('');
                // console.log(name, eq.V, rgb, color)
                this.context.fillStyle = color;
                this.context.beginPath();
                this.context.arc(x, y, radius, 0, 2 * Math.PI);
                this.context.fill();
                // if (this.options.labelConstituents) {
                // 	this.context.fillStyle = 'black'
                // 	const textProps = this.context.measureText(name)
                // 	this.context.fillText(
                // 		name,
                // 		x - textProps.width / 2,
                // 		y + textProps.actualBoundingBoxAscent / 2,
                // 	)
                // }
            }
        }
    }
    // reads: periodHiPass, periodLoPass
    stationLevelAtTime(time) {
        return StationLevelAtTime(this.station, time, (c) => {
            const revolutionsPerDay = (c.degreesPerSecond * (24 * 60 * 60)) / 360;
            const daysPerRev = 1 / revolutionsPerDay;
            const logDaysPerRev = Math.log2(daysPerRev);
            return (logDaysPerRev > this.options.periodHiPass &&
                logDaysPerRev < this.options.periodLoPass);
        });
    }
    renderCrosshairs() {
        // Null Zone
        this.context.beginPath();
        this.context.fillStyle = '#00a322';
        this.context.moveTo(this.dimensions.centerX, this.dimensions.centerY);
        const { r } = this.getCoordForData(0, { daysPerRev: 1 / 15 });
        this.context.arc(this.dimensions.centerX, this.dimensions.centerY, r, 0, 2 * Math.PI);
        this.context.fill();
        // Crosshairs
        this.context.lineWidth = 2;
        this.context.strokeStyle = '#00a322cc';
        this.context.beginPath();
        this.context.moveTo(this.dimensions.left, this.dimensions.centerY);
        this.context.lineTo(this.dimensions.right, this.dimensions.centerY);
        this.context.moveTo(this.dimensions.centerX, this.dimensions.top);
        this.context.lineTo(this.dimensions.centerX, this.dimensions.bottom);
        this.context.moveTo(this.dimensions.centerX, this.dimensions.centerY);
        this.context.stroke();
        let i = 0;
        for (const daysPerRev of [1 / 4, 1, 4, 16, 64, 256, 1024]) {
            this.context.beginPath();
            if (i % 2 === 0) {
                this.context.lineWidth = 1;
                this.context.setLineDash([5, 10]);
            }
            else {
                this.context.lineWidth = 2;
                this.context.setLineDash([10, 5]);
            }
            i++;
            const { r } = this.getCoordForData(0, { daysPerRev: daysPerRev });
            this.context.arc(this.dimensions.centerX, this.dimensions.centerY, r, 0, 2 * Math.PI);
            this.context.stroke();
        }
        this.context.setLineDash([]);
    }
    renderClippingPath() {
        this.context.beginPath();
        this.context.lineWidth = 20;
        this.context.strokeStyle = '#000000';
        this.context.arc(this.dimensions.centerX, this.dimensions.centerY, this.activeRadius, 0, Math.PI * 2);
        this.context.stroke();
        this.context.clip();
    }
    renderBackground() {
        this.context.fillStyle = '#28caf9';
        this.context.fillRect(this.dimensions.left, this.dimensions.top, this.dimensions.right, this.dimensions.bottom);
    }
    getCoordForData(angle, speed) {
        const MAX_DIST = 22.2;
        const revsPerHour = speed.revsPerHour ?? 1 / speed.daysPerRev / 24;
        const logArg = (1 / revsPerHour ** 2) * (16 / 36);
        const distance = logArg > 1 ? Math.log(logArg) : 0;
        const radius = this.activeRadius;
        return {
            r: scale(distance, 0, MAX_DIST, 0, radius),
            x: scale(distance * sin(angle), -MAX_DIST, MAX_DIST, this.dimensions.centerX - radius, this.dimensions.centerX + radius),
            y: scale(distance * cos(angle), -MAX_DIST, MAX_DIST, this.dimensions.centerY + radius, this.dimensions.centerY - radius),
        };
    }
}

class Gauge extends CanvasElement {
    options;
    constructor(context, drawZone, options) {
        super(context, drawZone);
        this.options = options;
    }
    attachObservable(inputName, view) {
        this.store.add(view((v) => {
            if (this.options[inputName] !== v) {
                this.options[inputName] = v;
                requestAnimationFrame(() => {
                    this.render();
                });
            }
        }));
    }
    render() {
        this.context.save();
        this.context.fillStyle = '#ffffff';
        this.context.beginPath();
        this.context.lineWidth = 20;
        this.context.strokeStyle = '#000000';
        this.traceCircle(0.9);
        this.context.stroke();
        this.context.fill();
        this.context.beginPath();
        this.context.lineWidth = 3;
        const valPercent = scale(this.options.value, this.options.min, this.options.max, 0, 1);
        const bounded = bound2(valPercent, 0, 1);
        const valAngle = sploot(bounded, this.options.minAngle, this.options.maxAngle);
        this.moveTo(0, 0);
        const r = 0.7;
        this.traceLine(r * cos(valAngle), -r * sin(valAngle));
        this.context.stroke();
        this.context.restore();
    }
}

class Clock extends CanvasElement {
    options;
    lastTimeUpdateTime;
    constructor(context, drawZone, options) {
        super(context, drawZone);
        this.options = options;
        this.lastTimeUpdateTime = Date.now();
        this.scaleFactor = this.dimensions.minDim * (3 / 7);
        this.resetAutoAdvanceTimer();
        this.store.add({ dispose: () => this.autoAdvanceDisposables.clear() });
    }
    attachObservable(inputName, view) {
        const toRunOnChange = {
            timeRate: () => {
                this.resetAutoAdvanceTimer();
            },
            refreshTimeout: () => {
                this.resetAutoAdvanceTimer();
            },
            time: () => {
                this.lastTimeUpdateTime = Date.now();
            },
        };
        this.store.add(view((v) => {
            if (this.options[inputName] !== v) {
                this.options[inputName] = v;
                requestAnimationFrame(() => {
                    this.render();
                });
                toRunOnChange[inputName]?.();
            }
        }));
    }
    // reads: timeRate, refreshTimeout
    autoAdvanceDisposables = new DisposableStore();
    resetAutoAdvanceTimer() {
        this.autoAdvanceDisposables.clear();
        const timeout = this.options.refreshTimeout;
        if (timeout < 10) {
            const handle = window.requestAnimationFrame(() => {
                if (!this.active) {
                    this.render();
                }
                this.resetAutoAdvanceTimer();
            });
            this.autoAdvanceDisposables.add({
                dispose: () => window.cancelAnimationFrame(handle),
            });
        }
        else {
            const handle = window.setTimeout(() => {
                if (!this.active) {
                    this.render();
                }
                this.resetAutoAdvanceTimer();
            }, timeout);
            this.autoAdvanceDisposables.add({
                dispose: () => window.clearTimeout(handle),
            });
        }
    }
    render() {
        const getShowTime = () => {
            const extrapolatedTime = this.extrapolateTime();
            const timezoneOffset = this.options.offset * 60 * 1000;
            const timeToShow = extrapolatedTime - timezoneOffset;
            const startOfDayInTimezone = new Date(timeToShow);
            startOfDayInTimezone.setUTCHours(0, 0, 0, 0);
            const offset = timeToShow - +startOfDayInTimezone;
            const seconds = offset / 1000;
            const minutes = seconds / 60;
            const hours = minutes / 60;
            return { hours, minutes, seconds };
        };
        const renderCasing = () => {
            this.context.strokeStyle = '#000';
            this.context.beginPath();
            this.setLineWidth(0.1);
            this.context.fillStyle = '#222';
            this.traceCircle(1);
            this.context.stroke();
            this.context.fill();
            this.context.beginPath();
            this.context.fillStyle = '#000';
            this.traceCircle(0.85);
            this.context.fill();
            this.context.beginPath();
            this.context.fillStyle = '#333';
            this.traceCircle(0.83);
            this.context.fill();
        };
        const render12Count = () => {
            this.context.fillStyle = '#fff';
            Array.from({ length: 12 }, (_, i) => i + 1).forEach((h) => {
                const r = 0.68;
                const deg = scale(h, 0, 12, 90, -270);
                const { x, y } = this.getRect(r, deg);
                this.context.font = this.scaleFactor * 0.23 + 'px system-ui';
                this.fillText(x, y, String(h));
            });
        };
        const render60Count = () => {
            Array.from({ length: 12 }, (_, i) => i + 1).forEach((s) => {
                const r = 0.95;
                const deg = scale(s, 0, 12, 90, -270);
                const { x, y } = this.getRect(r, deg);
                this.context.font = this.scaleFactor * 0.07 + 'px system-ui';
                const displayNumber = s * 5;
                const rotation = {
                    5: -30,
                    10: -60,
                    20: 60,
                    25: 30,
                };
                this.withRotation(rotation[displayNumber % 30] ?? 0, x, y, () => {
                    this.fillText(x, y, String(displayNumber));
                });
            });
        };
        const render60Icons = () => {
            this.context.strokeStyle = '#fff';
            this.context.fillStyle = '#fff';
            Array.from({ length: 60 }, (_, i) => i + 1).forEach((s) => {
                const deg = scale(s, 0, 60, 90, -270);
                if (s % 60 === 0) {
                    this.context.beginPath();
                    this.moveTo(0, -0.85);
                    this.traceLine(0.04, -0.92);
                    this.traceLine(-0.04, -0.92);
                    this.traceLine(-0, -0.85);
                    this.context.fill();
                }
                else if (s % 15 === 0) {
                    this.context.beginPath();
                    this.setLineWidth(0.05);
                    this.traceRay(0.9, deg, 0, 0, 0.85);
                    this.context.stroke();
                }
                else if (s % 5 === 0) {
                    const { x, y } = this.getRect(0.875, deg);
                    this.context.beginPath();
                    this.traceCircle(0.025, x, y);
                    this.context.fill();
                }
                else {
                    this.context.beginPath();
                    this.setLineWidth(0.02);
                    this.traceRay(0.9, deg, 0, 0, 0.85);
                    this.context.stroke();
                }
            });
        };
        const renderHourHand = () => {
            const hourAngle = scale(wrap(hours, 12), 0, 12, 90, -270);
            const rHour = 0.55;
            this.withRotation(hourAngle, 0, 0, () => {
                this.context.fillStyle = '#444';
                this.context.strokeStyle = '#000';
                this.setLineWidth(0.015);
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.1);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceLine(rHour * (0 / 3), rHour * (1 / 30));
                this.traceLine(rHour * (2 / 3), rHour * (5 / 30));
                this.traceLine(rHour * (3 / 3), rHour * (0 / 30));
                this.traceLine(rHour * (2 / 3), rHour * (-5 / 30));
                this.traceLine(rHour * (0 / 3), rHour * (-1 / 30));
                this.traceLine(0, 0);
                this.context.stroke();
                this.context.fill();
                this.context.fillStyle = '#fff';
                this.context.beginPath();
                this.traceLine(rHour * (1 / 3), rHour * (3 / 30));
                this.traceLine(rHour * (2 / 3), rHour * (5 / 30));
                this.traceLine(rHour * (3 / 3), rHour * (0 / 30));
                this.traceLine(rHour * (2 / 3), rHour * (-5 / 30));
                this.traceLine(rHour * (1 / 3), rHour * (-3 / 30));
                this.context.fill();
                this.context.fillStyle = '#444';
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.1);
                this.context.fill();
            });
        };
        const renderMinuteHand = () => {
            const minuteAngle = scale(wrap(minutes, 60), 0, 60, 90, -270);
            const rMinute = 0.79;
            this.withRotation(minuteAngle, 0, 0, () => {
                this.context.fillStyle = '#444';
                this.context.strokeStyle = '#000';
                this.setLineWidth(0.015);
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.08);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceLine(rMinute * (0 / 3), rMinute * (1 / 40));
                this.traceLine(rMinute * (2 / 3), rMinute * (3 / 40));
                this.traceLine(rMinute * (3 / 3), rMinute * (0 / 40));
                this.traceLine(rMinute * (2 / 3), rMinute * (-3 / 40));
                this.traceLine(rMinute * (0 / 3), rMinute * (-1 / 40));
                this.traceLine(0, 0);
                this.context.stroke();
                this.context.fill();
                this.context.fillStyle = '#fff';
                this.context.beginPath();
                this.traceLine(rMinute * (1 / 4), rMinute * (5 / 3 / 40));
                this.traceLine(rMinute * (2 / 3), rMinute * (3 / 40));
                this.traceLine(rMinute * (3 / 3), rMinute * (0 / 40));
                this.traceLine(rMinute * (2 / 3), rMinute * (-3 / 40));
                this.traceLine(rMinute * (1 / 4), rMinute * (-(5 / 3) / 40));
                this.context.fill();
                this.context.fillStyle = '#444';
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.08);
                this.context.fill();
            });
        };
        const renderTimer = () => {
            const timerAngle = scale(wrap(minutes, 60), 0, 60, 90, -270);
            const rTimer = 0.83;
            this.withRotation(timerAngle, 0, 0, () => {
                this.context.fillStyle = '#444';
                this.context.strokeStyle = '#000';
                this.setLineWidth(0.015);
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.06);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceLine(rTimer * (0 / 7), rTimer * (1 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (1 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (5 / 80));
                this.traceLine(rTimer * (7 / 7), rTimer * (0 / 40));
                this.traceLine(rTimer * (6 / 7), rTimer * (-5 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (-1 / 80));
                this.traceLine(rTimer * (0 / 7), rTimer * (-1 / 80));
                this.traceLine(0, 0);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.context.fillStyle = '#fff';
                this.traceLine(rTimer * (5 / 7), rTimer * (1 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (1 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (5 / 80));
                this.traceLine(rTimer * (7 / 7), rTimer * (0 / 40));
                this.traceLine(rTimer * (6 / 7), rTimer * (-5 / 80));
                this.traceLine(rTimer * (6 / 7), rTimer * (-1 / 80));
                this.traceLine(rTimer * (5 / 7), rTimer * (-1 / 80));
                this.context.fill();
                this.context.fillStyle = '#444';
                this.context.beginPath();
                this.moveTo(0, 0);
                this.traceCircle(0.06);
                this.context.fill();
            });
        };
        const renderSecondHand = () => {
            this.context.beginPath();
            this.moveTo(0, 0);
            this.setLineWidth(0.015);
            const secondAngle = scale(wrap(seconds, 60), 0, 60, 90, -270);
            const rSecond = 0.92;
            this.withRotation(secondAngle, 0, 0, () => {
                this.context.fillStyle = '#333';
                this.context.strokeStyle = '#000';
                const centerCircleDiameter = this.options.renderTimer ? 0.04 : 0.06;
                this.context.beginPath();
                this.traceCircle(centerCircleDiameter + 0.02, -0.4, 0);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.traceCircle(centerCircleDiameter, 0, 0);
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.moveTo(rSecond * -(2 / 5), rSecond * (1 / 30));
                this.traceLine(rSecond * (5 / 5), rSecond * (1 / 120));
                this.traceLine(rSecond * (5 / 5), rSecond * -(1 / 120));
                this.traceLine(rSecond * -(2 / 5), rSecond * -(1 / 30));
                this.context.stroke();
                this.context.fill();
                this.context.beginPath();
                this.traceCircle(centerCircleDiameter + 0.02, -(2 / 5), 0);
                this.context.fill();
                this.context.beginPath();
                this.traceCircle(centerCircleDiameter, 0, 0);
                this.context.fill();
                this.context.fillStyle = '#fff';
                this.context.beginPath();
                this.moveTo(rSecond * (1 / 6), rSecond * (2 / 90));
                this.traceLine(rSecond * (6 / 6), rSecond * (1 / 120));
                this.traceLine(rSecond * (6 / 6), rSecond * -(1 / 120));
                this.traceLine(rSecond * (1 / 6), rSecond * -(2 / 90));
                this.context.fill();
            });
        };
        const { hours, minutes, seconds } = getShowTime();
        this.context.save();
        renderCasing();
        render60Icons();
        if (this.options.render12Count) {
            render12Count();
        }
        if (this.options.render60Count) {
            render60Count();
        }
        renderHourHand();
        renderMinuteHand();
        if (this.options.renderTimer) {
            renderTimer();
        }
        if (this.options.renderSecondHand) {
            renderSecondHand();
        }
        this.context.restore();
    }
    // reads: time, lastUpdateTime, timeRate
    extrapolateTime() {
        const clockTimeSinceUpdate = Date.now() - this.lastTimeUpdateTime;
        const scaledTimeSinceUpdate = clockTimeSinceUpdate * this.options.timeRate;
        return this.options.time + scaledTimeSinceUpdate;
    }
}

const disposables = new DisposableStore();
const HOUR = 1000 * 60 * 60;
const DAY = HOUR * 24;
const canvas = document.querySelector('canvas');
const main = document.querySelector('main');
const config = document.querySelector('form');
if (!(canvas && main && config)) {
    throw Error('bad DOM, elements not found');
}
const makeConfigArea = (className, parent = config) => {
    const el = parent.appendChild(document.createElement('div'));
    el.className = className;
    return el;
};
const configs = [
    makeConfigArea('toggles'),
    makeConfigArea('toggles'),
    makeConfigArea('slider'),
    makeConfigArea('slider'),
    makeConfigArea('slider'),
    makeConfigArea('slider'),
];
const tideOScopeToggles = [
    makeConfigArea('toggle', configs[0]),
    makeConfigArea('toggle', configs[0]),
    makeConfigArea('toggle', configs[0]),
];
const clockToggles = [
    makeConfigArea('toggle', configs[1]),
    makeConfigArea('toggle', configs[1]),
    makeConfigArea('toggle', configs[1]),
];
configs[0].classList.add('flex');
configs[1].classList.add('flex');
const go = () => {
    disposables.clear();
    const ref = document.location.hash.slice(1);
    const active = Stations.find((s) => s.id === ref);
    if (!active) {
        throw Error('not found');
    }
    const { ctx, dim } = setupCanvas(canvas);
    const mainDrawZone = drawZoneForElement(main);
    // Background
    ctx.fillStyle = '#333';
    ctx.fillRect(dim.left, dim.top, dim.width, dim.height);
    const defaultOptions = {
        renderScale: 1,
        labelConstituents: false,
        yRange: 8,
        center: Date.now(),
        timeRange: 2 * DAY,
        timeRate: 1,
        renderMoon: true,
        renderSun: true,
        renderHarmonics: false,
        periodLoPass: 10,
        periodHiPass: -4,
    };
    // {
    // 	const timeGauge = new Clock(ctx, mainDrawZone, {
    // 		time: Date.now(),
    // 		offset: 480,
    // 		refreshTimeout: (1 / 60) * 1000,
    // 		timeRate: 1,
    // 	})
    // 	disposables.add(timeGauge)
    // }
    // return
    const tideOScope = new TideOScope(ctx, drawZoneForElement(main), active, defaultOptions);
    const constituentToggle = new Toggle(ctx, drawZoneForElement(tideOScopeToggles[2]), {
        label: 'Harmonics',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: defaultOptions.renderHarmonics,
    });
    const moonToggle = new Toggle(ctx, drawZoneForElement(tideOScopeToggles[0]), {
        label: 'Moon',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: defaultOptions.renderMoon,
    });
    const sunToggle = new Toggle(ctx, drawZoneForElement(tideOScopeToggles[1]), {
        label: 'Sun',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: defaultOptions.renderSun,
    });
    const secondToggle = new Toggle(ctx, drawZoneForElement(clockToggles[0]), {
        label: 'Seconds',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: false,
    });
    const numbers60Toggle = new Toggle(ctx, drawZoneForElement(clockToggles[1]), {
        label: '60-Count',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: false,
    });
    const numbers12Toggle = new Toggle(ctx, drawZoneForElement(clockToggles[2]), {
        label: '12-Count',
        onLabel: 'Show',
        offLabel: 'Hide',
        value: true,
    });
    const scrollSpeedSlider = new Slider(ctx, drawZoneForElement(configs[2]), {
        label: 'Scroll Speed',
        max: 100,
        min: 1,
        value: defaultOptions.timeRate,
    });
    const windowRangeSlider = new Slider(ctx, drawZoneForElement(configs[3]), {
        label: 'Window Range',
        min: -3,
        max: 15,
        value: defaultOptions.timeRange,
    });
    const highpassCutoff = new Slider(ctx, drawZoneForElement(configs[4]), {
        label: 'Hi Pass',
        min: -4,
        max: 10,
        value: defaultOptions.periodHiPass,
    });
    const lowpassCutoff = new Slider(ctx, drawZoneForElement(configs[5]), {
        label: 'Lo Pass',
        min: -4,
        max: 10,
        value: defaultOptions.periodLoPass,
    });
    new Date().getTimezoneOffset();
    const StationOffset = -(active.timezoneOffset ?? 0) * 60;
    const timeGauge = new Clock(ctx, {
        height: mainDrawZone.height / 4,
        width: mainDrawZone.width / 4,
        left: mainDrawZone.left + mainDrawZone.width * (3 / 4),
        top: mainDrawZone.top,
    }, {
        time: defaultOptions.center,
        offset: StationOffset,
        refreshTimeout: (1 / 60) * 1000,
        timeRate: defaultOptions.timeRate,
        render60Count: false,
        renderSecondHand: false,
        render12Count: true,
        renderTimer: false,
    });
    const heightGauge = new Gauge(ctx, {
        height: mainDrawZone.height / 4,
        width: mainDrawZone.width / 4,
        left: mainDrawZone.left,
        top: mainDrawZone.top,
    }, {
        label: 'Height',
        min: -8,
        max: 8,
        value: 0,
        minAngle: 250,
        maxAngle: -70,
    });
    tideOScope.attachObservable('renderHarmonics', constituentToggle.valueView);
    tideOScope.attachObservable('periodLoPass', lowpassCutoff.valueView);
    tideOScope.attachObservable('periodHiPass', highpassCutoff.valueView);
    tideOScope.attachObservable('renderMoon', moonToggle.valueView);
    tideOScope.attachObservable('renderSun', sunToggle.valueView);
    tideOScope.attachObservable('timeRange', windowRangeSlider.valueView);
    tideOScope.attachObservable('timeRate', scrollSpeedSlider.valueView);
    heightGauge.attachObservable('value', MappedView(tideOScope.centralDataView, (v) => v.total));
    timeGauge.attachObservable('time', MappedView(tideOScope.centralDataView, (v) => v.time));
    timeGauge.attachObservable('timeRate', scrollSpeedSlider.valueView);
    timeGauge.attachObservable('render60Count', numbers60Toggle.valueView);
    timeGauge.attachObservable('render12Count', numbers12Toggle.valueView);
    timeGauge.attachObservable('renderSecondHand', secondToggle.valueView);
    const allComponents = [
        windowRangeSlider,
        scrollSpeedSlider,
        highpassCutoff,
        lowpassCutoff,
        moonToggle,
        sunToggle,
        constituentToggle,
        tideOScope,
        heightGauge,
        timeGauge,
        numbers12Toggle,
        numbers60Toggle,
        secondToggle,
    ];
    disposables.add(...allComponents);
    allComponents.map((c) => c.render());
};
window.addEventListener('resize', go);
window.addEventListener('hashchange', go);
go();
//# sourceMappingURL=index.js.map
